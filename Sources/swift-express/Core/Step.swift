//===--- Step.swift ---------------------------------------------------------===//
//Copyright (c) 2015-2016 Daniel Leping (dileping)
//
//This file is part of Swift Express Command Line
//
//Swift Express Command Line is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
//Swift Express Command Line is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with Swift Express Command Line. If not, see <http://www.gnu.org/licenses/>.
//
//===------------------------------------------------------------------------===//

import Result


protocol Step {
    
    var dependsOn : [Step] { get }
    
    func run(_ params: [String: Any], combinedOutput: StepResponse) throws -> [String: Any]
    func cleanup(_ params:[String: Any], output: StepResponse) throws
    
    // Optional. Return unique string key for object
    func uniqueKey() -> String
    
    // Optional. Implement only if step depends on any another step and need to convert call parameters
    func callParams(_ ownParams: [String: Any], forStep: Step, previousStepsOutput: StepResponse) throws -> [String: Any]
    
    // Optional. Implement if you want handle revert on error. Error provided if generated by self.
    func revert(_ params:[String: Any], output: [String: Any]?, error: SwiftExpressError?)
}

extension Step {
    // Default realisation of callParams. Return own params
    func callParams(_ ownParams: [String: Any], forStep: Step, previousStepsOutput: StepResponse) throws -> [String: Any] {
        return ownParams
    }
    
    // Default realization of revert. Forward call to cleanup
    func revert(_ params:[String: Any], output: [String: Any]?, error: SwiftExpressError?) {
        if error != nil {
            print("Unhandled error in \(self.uniqueKey()). Error: \(error!)")
        }
    }
    
    // Default implementation of uniqueKey. Returns class name
    func uniqueKey() -> String {
        return String(describing: type(of: self))
    }
}

class StepResponse {
    let response:[String:Any]?
    let params:[String:Any]?
    
    let parents:[String: StepResponse]?
    
    init(params:[String: Any], response: [String: Any]) {
        self.response = response
        self.params = params
        self.parents = nil
    }
    
    init(parents: [String: StepResponse]) {
        self.response = nil
        self.params = nil
        self.parents = parents
    }
    
    init(params: [String: Any], response: [String: Any], parents: [String: StepResponse]) {
        self.response = response
        self.parents = parents
        self.params = params
    }
    
    func ownParam(key: String) -> Any? {
        if response != nil {
            if let val = response![key] {
                return val
            }
        }
        return nil
    }
    
    func parentsParam(key: String) -> Any? {
        if parents != nil {
            for (_, parent) in parents! {
                if let val = parent.ownParam(key: key) {
                    return val
                }
            }
            for (_, parent) in parents! {
                if let val = parent.parentsParam(key: key) {
                    return val
                }
            }
        }
        return nil
    }
    
    subscript(key: String) -> Any? {
        if response != nil {
            if let val = response![key] {
                return val
            }
        }
        if parents != nil {
            for (_, parent) in parents! {
                if let val = parent[key] {
                    return val
                }
            }
        }
        return nil
    }
}

struct StepRunner {
    private let _step: Step
    
    init(step: Step) {
        self._step = step
    }
    
    private func runRevert(_ steps: [Step], combinedOutput: [String: StepResponse]) {
        for errStep in steps.reversed() {
            errStep.revert(combinedOutput[errStep.uniqueKey()]!.params!, output: combinedOutput[errStep.uniqueKey()]?.response, error: nil)
            if errStep.dependsOn.count > 0 {
                runRevert(errStep.dependsOn, combinedOutput: combinedOutput[errStep.uniqueKey()]!.parents!)
            }
        }
    }
    
    private func runStep(_ step: Step, params: [String: Any]) throws -> StepResponse {
        var combinedOutput = [String : StepResponse]()
        for index in 0..<step.dependsOn.count {
            let prevStep = step.dependsOn[index]
            do {
                let prevParams = try step.callParams(params, forStep: prevStep, previousStepsOutput: StepResponse(parents: combinedOutput))
                combinedOutput[prevStep.uniqueKey()] = try runStep(prevStep, params: prevParams)
            } catch let err as SwiftExpressError {
                runRevert(Array(step.dependsOn[0..<index]), combinedOutput: combinedOutput)
                throw err
            } catch {
                let err = SwiftExpressError.unknownError(error: error)
                runRevert(Array(step.dependsOn[0..<index]), combinedOutput: combinedOutput)
                throw err
            }
        }
        do {
            let response = try step.run(params, combinedOutput: StepResponse(parents: combinedOutput))
            return StepResponse(params:params, response: response, parents: combinedOutput)
        } catch let err as SwiftExpressError {
            step.revert(params, output: nil, error: err)
            runRevert(step.dependsOn, combinedOutput: combinedOutput)
            throw err
        } catch {
            let err = SwiftExpressError.unknownError(error: error)
            step.revert(params, output: nil, error: err)
            runRevert(step.dependsOn, combinedOutput: combinedOutput)
            throw err
        }
    }
    
    private func runCleanup(_ step: Step, params: [String: Any], output: StepResponse) throws {
        do {
            try step.cleanup(params, output: output)
        } catch let err as SwiftExpressError {
            step.revert(params, output: output.response, error:  err)
            if step.dependsOn.count > 0 {
                runRevert(step.dependsOn, combinedOutput: output.parents!)
            }
            throw err
        } catch {
            let err = SwiftExpressError.unknownError(error: error)
            step.revert(params, output: output.response, error:  err)
            if step.dependsOn.count > 0 {
                runRevert(step.dependsOn, combinedOutput: output.parents!)
            }
            throw err
        }
        for index in (0..<step.dependsOn.count).reversed() {
            do {
                let parStep = step.dependsOn[index]
                let parOut = output.parents![parStep.uniqueKey()]!
                try runCleanup(parStep, params: parOut.params!, output: parOut)
            } catch {
                runRevert(Array(step.dependsOn[0..<index]), combinedOutput: output.parents!)
                throw error
            }
        }
    }
    
    func run(_ params: [String: Any]) throws {
        let response = try runStep(self._step, params: params)
        try runCleanup(self._step, params: params, output: response)
    }
}
